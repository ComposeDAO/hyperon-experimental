{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"CONTRIBUTING/","title":"How to contribute","text":""},{"location":"CONTRIBUTING/#making-changes","title":"Making changes","text":"<p>Before making changes create a personal fork of the repository. Sync fork and create new branch from the latest version of the <code>main</code> branch. Create separate branch for each change. Thus it is simpler to support consistent state of the <code>main</code> in your fork.</p> <p>Prefer incremental commits to one big commit which contains the whole change. Prefer commits which passes all of the tests. If it is not possible to satisfy both requirements at once you can make single commit which passes tests or mark tests as ignored until change is done.</p> <p>Each commit should have a message in the following format: <pre><code>Change summary in 50 characters (less than 73 characters)\n\nOptional detailed description of the change when required. Each line\nis less than 73 character long.\n</code></pre> Such commits looks better in GitHub history.</p> <p>Please avoid generic commit messages like <code>Update README.md</code>. Good commit message should describe the change, not a fact of the change. For example <code>Add troubleshooting section about No module named 'hyperonpy'</code>. By looking to the commit message history the reviewer should understand the order and brief description of changes.</p> <p>Please don't include number and description of the issue into a commit summary line. Use <code>Fixes #&lt;issue-number&gt;</code> in the pull request description instead to link the PR and the issue.</p> <p>PR should satisfy the following requirement before being merged: - contain latest changes from the repo; - pass tests; - be reviewed.</p> <p>Feel free to raise draft PR if you need an advice or help with your changes.</p>"},{"location":"CONTRIBUTING/#code-style","title":"Code style","text":"<p>We have small set of code style rules for now. The rule of thumb is to take a look at the existing code and stick to its style.</p>"},{"location":"CONTRIBUTING/#general","title":"General","text":"<p>If you want to leave some reminder in code, for example to fix something later, you can do it by two ways. Add a comment starting with <code>FIXME</code> to mark something which should be done before the PR is merged. Add a comment starting with <code>TODO</code> to mark the improvement which can be postponed and done later by a separate PR. The main purpose of a <code>TODO</code> comment is to trigger a developer who looks at the code after you and make him fix the issue if it is appropriate. If the change or question is big enough or it affects the API of the module it is better to raise an issue instead.</p>"},{"location":"CONTRIBUTING/#libraries","title":"Libraries","text":"<p>When adding new library into the project please ensure you specify the exact version instead of using ranges. The minor update of the library can break the build unexpectedly. The broken build is a real burden because most of the users build the project from the source.</p>"},{"location":"CONTRIBUTING/#rust","title":"Rust","text":"<p>When working on Rust C API prefer making <code>unsafe</code> blocks as small as possible. This makes it easier to find blocks that might be source of issues. Usually it is not required to mark C API functions <code>unsafe</code> because they are not intended to be used from the Rust safe code.</p>"},{"location":"minimal-metta/","title":"Minimal Metta","text":"<p>This document describes the minimal set of embedded MeTTa instructions which is enough to write the complete MeTTa interpreter in MeTTa. Current version of the document includes improvements which were added after experimenting with the first version of such an interpreter. It is not a final version and some directions of the future work is explained at the end of the document.</p>"},{"location":"minimal-metta/#minimal-instruction-set","title":"Minimal instruction set","text":""},{"location":"minimal-metta/#interpreter-state","title":"Interpreter state","text":"<p>The MeTTa interpreter interprets an atom passed as an input. It interprets it step by step on each step executing the single instruction. In order to do that the interpreter needs a context which is wider than the atom itself. The context also includes (see Explicit atomspace variable bindings): - an atomspace which contains the knowledge which drives the evaluation of the   expressions; - bindings of the variables which are used to evaluate expressions; the   bindings are empty at the beginning.</p> <p>Each step of interpretation inputs and outputs a list of pairs (<code>&lt;atom&gt;</code>, <code>&lt;bindings&gt;</code>) which is called an interpretation plan. Each pair in the plan represents one possible way of interpreting the original atom or possible branch of the evaluation. Interpreter doesn't select one of them for further processing. It continues interpreting all of the branches in parallel. This is what is called non-deterministic evaluation.</p> <p>One step of the interpretation is an execution of a single instruction from a plan. An interpreter removes the atom from the plan, executes it and adds the results back to the plan. Here we suppose that on the top level the plan contains only the instructions from the minimal set. It is not necessary but it allowed developing the first stable version with less effort (see <code>eval</code> and <code>Return</code>). If an instruction returns the atom which is not from the minimal set it is not interpreted further and returned as a part of the final result.</p>"},{"location":"minimal-metta/#erroremptynotreduciblevoid","title":"Error/Empty/NotReducible/Void","text":"<p>There are atoms which can be returned to designate a special situation in a code: - <code>(Error &lt;atom&gt; &lt;message&gt;)</code> means the interpretation is finished with error; - <code>Empty</code> means the corresponding branch of the evaluation returned no results,   such result is not returned among other results when interpreting is   finished; - <code>NotReducible</code> can be returned by <code>eval</code> in order to designate the situation   when function can not be reduced further; for example it can happen when code   tries to call a type constructor (which has no definition), partially defined   function (with argument values which are not handled), or grounded function   which returns <code>NotReducible</code> explicitly; this atom is introduced to separate   the situations when atom should be returned \"as is\" from <code>Empty</code> when atom   should be removed from results; - <code>Void</code> is a unit result which is mainly used by functions with side effects   which has no meaningful value to return.</p> <p>These atoms are not interpreted further as they are not a part of the minimal set of instructions.</p>"},{"location":"minimal-metta/#eval","title":"eval","text":"<p><code>(eval &lt;atom&gt;)</code> is a first instruction which evaluates an atom passed as an argument. Evaluation is different for the grounded function calls (the expression with a grounded atom on a first position) and pure MeTTa expressions. For the pure MeTTa expression the interpreter searches the <code>(= &lt;atom&gt; &lt;var&gt;)</code> expression in the atomspace. The found values of the <code>&lt;var&gt;</code> are the result of evaluation. Execution of the grounded atom leads to the call of the foreign function passing the tail of the expression as arguments. For example <code>(+ 1 2)</code> calls the implementation of addition with <code>1</code> and <code>2</code> as arguments.  The list of atoms returned by the grounded function is a result of the evaluation in this case. A grounded function can have side effects as well. In both cases bindings of the <code>eval</code>'s argument are merged to the bindings of the result.</p> <p>Atomspace search can bring the list of results which is empty. When search returns no results then <code>NotReducible</code> atom is a result of the instruction. Grounded function can return a list of atoms, empty result, <code>Error(&lt;message&gt;)</code> or <code>NoReduce</code> result. The result of the instruction for a special values are the following: - empty result returns <code>Void</code> atom; - <code>Error(&lt;message&gt;)</code> returns <code>(Error &lt;original-atom&gt; &lt;message&gt;)</code> atom; - <code>NoReduce</code> returns <code>NotReducible</code> atom.</p>"},{"location":"minimal-metta/#chain","title":"chain","text":"<p>A function call with a sub-expression as an argument can be interpreted using two different orders. The interpreter can evaluate the whole expression or evaluate the argument first and then insert the result into the original expression. The proper order of interpretation can depend on the type of the function.</p> <p><code>chain</code> instruction allows a programmer to control the order of the evaluation and interpret the subexpression first. It has a form <code>(chain &lt;atom&gt; &lt;var&gt; &lt;template&gt;)</code> and executed differently depending on what kind of <code>&lt;atom&gt;</code> is passed as a first argument: - if <code>&lt;atom&gt;</code> is an instruction from the minimal set then chain executes it and   returns <code>(chain &lt;execution-result&gt; &lt;var&gt; &lt;template&gt;)</code>; bindings of the    are merged to the bindings of the result; - it substitutes all occurrences of <code>&lt;var&gt;</code> in <code>&lt;template&gt;</code> by the <code>&lt;atom&gt;</code>   otherwise.  When execution of the <code>&lt;atom&gt;</code> brings more than a single result   <code>chain</code> returns one <code>(chain ...)</code> expression for each result. <code>chain</code> can be   nested in such a case only the most nested <code>chain</code> instruction is executed   during the interpretation step."},{"location":"minimal-metta/#unify","title":"unify","text":"<p>Conditioning on the results can be done using <code>unify</code> operation <code>(unify &lt;atom&gt; &lt;pattern&gt; &lt;then&gt; &lt;else&gt;)</code>. This operation matches <code>&lt;atom&gt;</code> with a <code>&lt;pattern&gt;</code>. If match is successful then it returns <code>&lt;then&gt;</code> atom and merges bindings of the original <code>&lt;atom&gt;</code> to resulting variable bindings. If matching is not successful then it returns the <code>&lt;else&gt;</code> branch with the original variable bindings.</p>"},{"location":"minimal-metta/#consdecons","title":"cons/decons","text":"<p>Last pair of operations are <code>cons</code> and <code>decons</code> to construct and deconstruct the expression atom from/to head and tail. <code>(decons &lt;expr&gt;)</code> returns: - <code>()</code> when <code>&lt;expr&gt;</code> is empty; - <code>(&lt;head&gt; &lt;tail&gt;)</code> when <code>&lt;expr&gt;</code> is not empty.</p> <p><code>(cons &lt;head&gt; &lt;tail&gt;)</code> returns an expression where the first sub-atom is <code>&lt;head&gt;</code> and others are copied from <code>&lt;tail&gt;</code>.</p>"},{"location":"minimal-metta/#examples","title":"Examples","text":"<p>Examples of the programs written using minimal MeTTa interpreter:</p> <p>Switch implementation:</p> <pre><code>(= (switch $atom $cases)\n  (chain (decons $cases) $list\n    (chain (eval (switch-internal $atom $list)) $res\n      (unify $res NotReducible Empty $res) )))\n(= (switch-internal $atom (($pattern $template) $tail))\n  (unify $atom $pattern $template (eval (switch $atom $tail))))\n</code></pre> <p>Reduce in loop until result is calculated:</p> <pre><code>(= (subst $atom $var $templ)\n  (unify $atom $var $templ\n    (Error (subst $atom $var $templ)\n      \\\"subst expects a variable as a second argument\\\") ))\n\n(= (reduce $atom $var $templ)\n  (chain (eval $atom) $res\n    (unify $res Empty\n    Empty\n    (unify $res (Error $a $m)\n      (Error $a $m)\n      (unify $res NotReducible\n        (eval (subst $atom $var $templ))\n        (eval (reduce $res $var $templ)) )))))\n</code></pre> <p>Link to the full code of the interpreter in MeTTa (not finished yet).</p>"},{"location":"minimal-metta/#properties","title":"Properties","text":""},{"location":"minimal-metta/#turing-completeness","title":"Turing completeness","text":"<p>The following program implements a Turing machine using the minimal MeTTa instruction set (the full code of the example can be found here):</p> <pre><code>           (= (tm $rule $state $tape)\n              (unify $state HALT\n                $tape\n                (chain (eval (read $tape)) $char\n                  (chain (eval ($rule $state $char)) $res\n                    (unify $res ($next-state $next-char $dir)\n                      (chain (eval (move $tape $next-char $dir)) $next-tape\n                        (eval (tm $rule $next-state $next-tape)) )\n                      (Error (tm $rule $state $tape) \\\"Incorrect state\\\") )))))\n\n            (= (read ($head $hole $tail)) $hole)\n\n            (= (move ($head $hole $tail) $char N) ($head $char $tail))\n            (= (move ($head $hole $tail) $char L)\n              (chain (cons $char $head) $next-head\n                (chain (decons $tail) $list\n                  (unify $list ($next-hole $next-tail)\n                    ($next-head $next-hole $next-tail)\n                    ($next-head 0 ()) ))))\n            (= (move ($head $hole $tail) $char R)\n              (chain (cons $char $tail) $next-tail\n                (chain (decons $head) $list\n                  (unify $list ($next-hole $next-head)\n                    ($next-head $next-hole $next-tail)\n                    (() 0 $next-tail) ))))\n</code></pre>"},{"location":"minimal-metta/#comparison-with-metta-operational-semantics","title":"Comparison with MeTTa Operational Semantics","text":"<p>One difference from MOPS [1] is that the minimal instruction set allows relatively easy write deterministic programs and non-determinism is injected only via matching and evaluation. <code>Query</code> and <code>Chain</code> from MOPS are very similar to <code>eval</code>. <code>Transform</code> is very similar to <code>unify</code>. <code>chain</code> has no analogue in MOPS, it is used to make deterministic computations. <code>cons</code>/<code>decons</code> to some extent are analogues of <code>AtomAdd</code>/<code>AtomRemove</code> in a sense that they can be used to change the state.</p>"},{"location":"minimal-metta/#eval-or-return","title":"eval or return","text":"<p>Using <code>eval</code> to designate evaluation of the atom seems too verbose. But we need to give a programmer some way to designate whether the atom should be evaluated or not. <code>eval</code> marks atoms which should be evaluated. As an alternative to this solution we could mark atoms which should not be evaluated.</p> <p>For example we could use a special instruction <code>(return &lt;atom&gt;)</code> which basically does nothing. When <code>return</code> is on the top level of the interpretation plan then the interpreter puts <code>&lt;atom&gt;</code> into the list of the final results. Other atoms on the top of the plan are evaluated. <code>chain</code> should be changed to have the same semantics: evaluate any atom except <code>(return ...)</code> and insert the <code>(return ...)</code> into the template.</p> <p>The version of the <code>reduce</code> written using <code>return</code> will look like the following: <pre><code>(= (reduce $atom $var $templ)\n  (chain $atom $res\n    (unify $res (return (Error $a $m))\n      (return (Error $a $m))\n      (unify $res (return Empty)\n        (subst $atom $var $templ)\n        (unify $res (return $val)\n          (subst $val $var $templ)\n          (reduce $res $var $templ) )))))\n</code></pre></p> <p>This version has one more interesting property: a programmer can use <code>(return &lt;atom&gt;)</code> to designate that the process of reducing should be finished. Otherwise the reduction stops only when an atom cannot be evaluated further. Thus the <code>return</code> idea can also be used in the MeTTa interpreter to control an execution and improve performance.</p> <p>We could also implement <code>chain</code> which removes <code>return</code> and inserts <code>&lt;atom&gt;</code> into the template. It can make program even more compact: <pre><code>(= (reduce $atom $var $templ)\n  (chain $atom $res\n    (unify $res (Error $a $m)\n      (Error $a $m)\n      (unify $res Empty\n        (subst $atom $var $templ)\n        (reduce $res $var $templ) ))))\n</code></pre></p> <p>But in such a case there is a risk of getting <code>(chain (return &lt;atom&gt;) $x $x)</code> which continues evaluation of the <code>&lt;atom&gt;</code> further while it is not expected.</p> <p>The final convention can be chosen from a usability perspective. Although it may seem that eliminating <code>eval</code> is the most convenient solution, it is not obvious. <code>eval</code> is a kind of <code>call</code> in assembly language and writing it explicitly makes the author think about whether the atom can be called.</p>"},{"location":"minimal-metta/#partial-and-complete-functions","title":"Partial and complete functions","text":"<p>Each instruction in a minimal instruction set is a complete function. Nevertheless <code>Empty</code> allows defining partial functions in MeTTa. For example partial <code>if</code> can be defined as follows: <pre><code>(= (if $condition $then) (unify $condition True $then Empty))\n</code></pre></p>"},{"location":"minimal-metta/#future-work","title":"Future work","text":""},{"location":"minimal-metta/#explicit-atomspace-variable-bindings","title":"Explicit atomspace variable bindings","text":"<p>Current implementation implicitly keeps and applies variable bindings during the process of the interpretation. It can be easily made explicit but the value of explicit bindings is not obvious see [discussion in issue</p>"},{"location":"minimal-metta/#290httpsgithubcomtrueagi-iohyperon-experimentalissues290issuecomment-1541314289","title":"290](https://github.com/trueagi-io/hyperon-experimental/issues/290#issuecomment-1541314289).","text":"<p>Making atomspace out of implicit context could make import semantics more straightforward. In the current implementation of the minimal instruction set it was needed to explicitly pass the atomspace to the interpreter because otherwise grounded <code>get-type</code> function didn't work properly.It also could allow defining <code>eval</code> via <code>unify</code> which minimizes the number of instructions and allows defining <code>eval</code> in a MeTTa program itself. Which in turn allows defining different versions of <code>eval</code> to program different kinds of chaining. Nevertheless defining <code>eval</code> through <code>unify</code> requires rework of the grounded functions interface to allow calling them by executing <code>unify</code> instructions. Which is an interesting direction to follow.</p>"},{"location":"minimal-metta/#scope-of-variables","title":"Scope of variables","text":"<p>Scope of the variable inside instructions is not described in this specification. It is a clear gap and one of the todo items.</p>"},{"location":"minimal-metta/#collapse","title":"Collapse","text":"<p>The described language allows transforming the atom into a non-deterministic result using <code>eval</code>, but there is no reversed instruction. As a consequence one cannot implement <code>collapse</code> using the instruction set above. In order to add such possibility the additional instruction is needed. It could mark a set of results as joined and when their evaluation is finished would assemble them into an expression.</p>"},{"location":"minimal-metta/#special-matching-syntax","title":"Special matching syntax","text":"<p>Sometimes it is convenient to change the semantics of the matching within a pattern. Some real examples are provided below. One possible way to extend matching syntax is embrace atoms by expressions with matching modifier on a first position. For instance <code>(:&lt;mod&gt; &lt;atom&gt;)</code> could apply <code>&lt;mod&gt;</code> rule to match the <code>&lt;atom&gt;</code>. How to eliminate interference of this syntax with symbol atoms used by programmers is an open question.</p>"},{"location":"minimal-metta/#syntax-to-match-atom-by-equality","title":"Syntax to match atom by equality","text":"<p>In many situations we need to check that atom is equal to some symbol. <code>unify</code> doesn't work well in such cases because when checked atom is a variable it is matched with anything (for instance <code>(unify $x Empty then else)</code> returns <code>then</code>). It would be convenient to have a special syntax to match the atom by equality. For instance <code>(unify &lt;atom&gt; (:= Empty) then else)</code> should match <code>&lt;atom&gt;</code> with pattern only when <code>&lt;atom&gt;</code> is <code>Empty</code>.</p>"},{"location":"minimal-metta/#syntax-to-match-part-of-the-expression","title":"Syntax to match part of the expression","text":"<p>We could have a specific syntax which would allow matching part of the expressions. For example such syntax could be used to match head and tail of the expression without using <code>cons</code>/<code>decons</code>. Another example is matching part of the expression with some gap, i.e. <code>(A ... D ...)</code> could match <code>(A B C D E)</code> atom.</p>"},{"location":"minimal-metta/#links","title":"Links","text":"<ol> <li>Lucius Gregory Meredith, Ben Goertzel, Jonathan Warrell, and Adam    Vandervorst. Meta-MeTTa: an operational semantics for MeTTa.    https://raw.githubusercontent.com/leithaus/rho4u/main/ai/mops/mops.pdf</li> </ol>"},{"location":"reference/atoms/","title":"Atoms","text":""},{"location":"reference/atoms/#hyperon.atoms","title":"atoms","text":"<p>The Python wrapper for Hyperon Atom Rust types</p>"},{"location":"reference/atoms/#hyperon.atoms.Atom","title":"Atom","text":"<pre><code>Atom(catom)\n</code></pre> <p>Represents an Atom of any type</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n\"\"\"Initialize an Atom\"\"\"\nself.catom = catom\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees an Atom and all associated resources.\"\"\"\n#import sys; sys.stderr.write(\"Atom._del_(\" + str(self) + \")\\n\"); sys.stderr.flush()\nhp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\nreturn (isinstance(other, Atom) and\nhp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a human-readable text description of the Atom.\"\"\"\nreturn hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n\"\"\"Gets the type of the current Atom instance\"\"\"\nreturn hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n\"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\nres = hp.atom_iterate(self.catom)\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Atom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n\"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\nreturn BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.AtomType","title":"AtomType","text":"<p>Defines all Atom types</p>"},{"location":"reference/atoms/#hyperon.atoms.Bindings","title":"Bindings","text":"<pre><code>Bindings(bindings: Union[hp.CBindings, None] = None)\n</code></pre> <p>Interface for working with atom matching and variable-to-atom binding.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, bindings: Union[hp.CBindings, None] = None):\n\"\"\"Initializes with or without pre-existing bindings.\"\"\"\nif bindings is None:\nself.cbindings = hp.bindings_new()\nelse:\nself.cbindings = bindings\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict = {})\n</code></pre> <p>Makes a \"deep copy\" of the bindings.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n\"\"\"Makes a \"deep copy\" of the bindings.\"\"\"\nreturn self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the binding resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees the binding resources.\"\"\"\nif self.cbindings is not None:\nhp.bindings_free(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n\"\"\"For context management.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two bindings objects contain identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if two bindings objects contain identical associations.\"\"\"\nreturn (isinstance(other, Bindings) and\nhp.bindings_eq(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n\"\"\"Frees resources on exit.\"\"\"\nif self.cbindings is not None:\nhp.bindings_free(self.cbindings)\nself.cbindings = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a text description of the bindings\"\"\"\nreturn hp.bindings_to_str(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: Union[str, Atom], atom: Atom) -&gt; bool\n</code></pre> <p>Adds a binding between a variable and an Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: Union[str, Atom], atom: Atom) -&gt; bool:\n\"\"\"Adds a binding between a variable and an Atom.\"\"\"\nif isinstance(var, Atom):\nreturn hp.bindings_add_var_binding(self.cbindings, var.get_name(), atom.catom)\nelse:\nreturn hp.bindings_add_var_binding(self.cbindings, var, atom.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n\"\"\"Makes a \"deep copy\" of the bindings\"\"\"\nreturn Bindings(hp.bindings_clone(self.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a bindings contains no associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"Checks if a bindings contains no associations.\"\"\"\nreturn hp.bindings_is_empty(self.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over the variable-atom pairs in the bindings</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n\"\"\"Returns an iterator over the variable-atom pairs in the bindings\"\"\"\nres = hp.bindings_list(self.cbindings)\nresult = []\nfor r in res:\nresult.append((r[0], Atom._from_catom(r[1])))\nreturn iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.merge","title":"merge","text":"<pre><code>merge(other: Bindings) -&gt; BindingsSet\n</code></pre> <p>Merges with another Bindings instance, into a Bindings Set.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge(self, other: 'Bindings') -&gt; 'BindingsSet':\n\"\"\"Merges with another Bindings instance, into a Bindings Set.\"\"\"\nreturn BindingsSet(hp.bindings_merge(self.cbindings, other.cbindings))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.narrow_vars","title":"narrow_vars","text":"<pre><code>narrow_vars(vars)\n</code></pre> <p>Keeps only specific variable associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def narrow_vars(self, vars ):\n\"\"\"Keeps only specific variable associations.\"\"\"\ncvars = hp.CVecAtom = hp.atom_vec_new()\nfor var in vars:\nhp.atom_vec_push(cvars, var.catom)\nhp.bindings_narrow_vars(self.cbindings, cvars)\nhp.atom_vec_free(cvars)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.resolve","title":"resolve","text":"<pre><code>resolve(var_name: str) -&gt; Union[Atom, None]\n</code></pre> <p>Finds the atom for a given variable name</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def resolve(self, var_name: str) -&gt; Union[Atom, None]:\n\"\"\"Finds the atom for a given variable name\"\"\"\nraw_atom = hp.bindings_resolve(self.cbindings, var_name)\nreturn None if raw_atom is None else Atom._from_catom(raw_atom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.Bindings.resolve_and_remove","title":"resolve_and_remove","text":"<pre><code>resolve_and_remove(var_name: str) -&gt; Union[Atom, None]\n</code></pre> <p>Finds and removes the atom for a given variable name</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def resolve_and_remove(self, var_name: str) -&gt; Union[Atom, None]:\n\"\"\"Finds and removes the atom for a given variable name\"\"\"\nraw_atom = hp.bindings_resolve_and_remove(self.cbindings, var_name)\nreturn None if raw_atom is None else Atom._from_catom(raw_atom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet","title":"BindingsSet","text":"<pre><code>BindingsSet(input: Union[hp.CBindingsSet, Bindings, None] = None)\n</code></pre> <p>Represents a set of Bindings frames, potentially expressing all possible matches produced by a match operation.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, input: Union[hp.CBindingsSet, Bindings, None] = None):\n\"\"\"Initializes with optional input.\"\"\"\nself.shadow_list = None # A lazily initialized list that shadows the BindingsSet values for indexed access\nif input is None:\nself.c_set = hp.bindings_set_single()\nelif isinstance(input, Bindings):\nself.c_set = hp.bindings_set_from_bindings(input.cbindings)\nelse:\nself.c_set = input\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memodict = {})\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __deepcopy__(self, memodict={}):\n\"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\nreturn self.clone()\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees the BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees the BindingsSet\"\"\"\nif self.c_set is not None:\nhp.bindings_set_free(self.c_set)\nself.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>For context management.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __enter__(self):\n\"\"\"For context management.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if other BindingsSet contains identical associations.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if other BindingsSet contains identical associations.\"\"\"\nreturn (isinstance(other, BindingsSet) and\nhp.bindings_set_eq(self.c_set, other.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Frees resources on exit.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n\"\"\"Frees resources on exit.\"\"\"\nif self.c_set is not None:\nhp.bindings_set_free(self.c_set)\nself.c_set = None\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Gets a Bindings frame by index</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __getitem__(self, key):\n\"\"\"Gets a Bindings frame by index\"\"\"\nif self.shadow_list is None:\nresult = hp.bindings_set_unpack(self.c_set)\nself.shadow_list = [{k: Atom._from_catom(v) for k, v in bindings.items()} for bindings in result]\nreturn self.shadow_list[key]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a text description of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a text description of a BindingsSet\"\"\"\nreturn hp.bindings_set_to_str(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_binding","title":"add_var_binding","text":"<pre><code>add_var_binding(var: Union[str, Atom], value: Atom) -&gt; bool\n</code></pre> <p>Adds a new variable to atom association to every Bindings frame in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_binding(self, var: Union[str, Atom], value: Atom) -&gt; bool:\n\"\"\"Adds a new variable to atom association to every Bindings frame in a\n    BindingsSet.\n    \"\"\"\nself.shadow_list = None\nif isinstance(var, Atom):\nreturn hp.bindings_set_add_var_binding(self.c_set, var.catom, value.catom)\nelse:\nreturn hp.bindings_set_add_var_binding(self.c_set, V(var), value.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.add_var_equality","title":"add_var_equality","text":"<pre><code>add_var_equality(a: Atom, b: Atom) -&gt; bool\n</code></pre> <p>Asserts equality between two Variable atoms in a BindingsSet.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def add_var_equality(self, a: Atom, b: Atom) -&gt; bool:\n\"\"\"Asserts equality between two Variable atoms in a BindingsSet.\"\"\"\nself.shadow_list = None\nreturn hp.bindings_set_add_var_equality(self.c_set, a.catom, b.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.clone","title":"clone","text":"<pre><code>clone()\n</code></pre> <p>Makes a \"deep copy\" of a BindingsSet</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def clone(self):\n\"\"\"Makes a \"deep copy\" of a BindingsSet\"\"\"\nreturn BindingsSet(hp.bindings_set_clone(self.c_set))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.empty","title":"empty","text":"<pre><code>empty()\n</code></pre> <p>Creates a new BindingsSet without any Bindings frames. Conceptually, this means no valid matches exist.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def empty():\n\"\"\"Creates a new BindingsSet without any Bindings frames.\n    Conceptually, this means no valid matches exist.\n    \"\"\"\nreturn BindingsSet(hp.bindings_set_empty())\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Checks if a BindingsSet contains no Bindings frames, and thus indicates no match.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"Checks if a BindingsSet contains no Bindings frames, and thus indicates\n    no match.\"\"\"\nreturn hp.bindings_set_is_empty(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.is_single","title":"is_single","text":"<pre><code>is_single() -&gt; bool\n</code></pre> <p>Checks if a Bindings set contains a frame with no associations, and thus allows variables to take any value.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def is_single(self) -&gt; bool:\n\"\"\"Checks if a Bindings set contains a frame with no associations, and\n    thus allows variables to take any value.\n    \"\"\"\nreturn hp.bindings_set_is_single(self.c_set)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.iterator","title":"iterator","text":"<pre><code>iterator()\n</code></pre> <p>Returns an iterator over all Bindings frames</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterator(self):\n\"\"\"Returns an iterator over all Bindings frames\"\"\"\nres = hp.bindings_set_list(self.c_set)\nresult = []\nfor r in res:\nresult.append(Bindings(r))\nreturn iter(result)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.merge_into","title":"merge_into","text":"<pre><code>merge_into(input: Union[BindingsSet, Bindings])\n</code></pre> <p>Merges the contents of another BindingsSet or Bindings frame.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def merge_into(self, input: Union['BindingsSet', Bindings]):\n\"\"\"Merges the contents of another BindingsSet or Bindings frame.\"\"\"\nself.shadow_list = None\nif isinstance(input, BindingsSet):\nhp.bindings_set_merge_into(self.c_set, input.c_set);\nelse:\nnew_set = BindingsSet(input);\nhp.bindings_set_merge_into(self.c_set, new_set.c_set);\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push","title":"push","text":"<pre><code>push(bindings: Bindings)\n</code></pre> <p>Adds a Bindings frame to an existing BindingsSet</p>"},{"location":"reference/atoms/#hyperon.atoms.BindingsSet.push--parameters","title":"Parameters","text":"<p>bindings:     The Bindings set to incorporate into set. Ownership of this argument is     taken by this function.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def push(self, bindings: Bindings):\n\"\"\"Adds a Bindings frame to an existing BindingsSet\n    Parameters\n    ----------\n    bindings:\n        The Bindings set to incorporate into set. Ownership of this argument is\n        taken by this function.\n    \"\"\"\nself.shadow_list = None\nhp.bindings_set_push(self.c_set, bindings.cbindings)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom","title":"ExpressionAtom","text":"<pre><code>ExpressionAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>An ExpressionAtom combines different kinds of Atoms, including expressions.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n\"\"\"Initialize an expression atom\"\"\"\nsuper().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees an Atom and all associated resources.\"\"\"\n#import sys; sys.stderr.write(\"Atom._del_(\" + str(self) + \")\\n\"); sys.stderr.flush()\nhp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\nreturn (isinstance(other, Atom) and\nhp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a human-readable text description of the Atom.\"\"\"\nreturn hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_children","title":"get_children","text":"<pre><code>get_children()\n</code></pre> <p>Returns all children Atoms of an expression</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_children(self):\n\"\"\"Returns all children Atoms of an expression\"\"\"\nreturn [Atom._from_catom(catom) for catom in hp.atom_get_children(self.catom)]\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n\"\"\"Gets the type of the current Atom instance\"\"\"\nreturn hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n\"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\nres = hp.atom_iterate(self.catom)\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ExpressionAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n\"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\nreturn BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom","title":"GroundedAtom","text":"<pre><code>GroundedAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>A GroundedAtom represents sub-symbolic knowledge. At the API level, it allows keeping data and behaviour inside an Atom. There are three aspects of a GroundedAtom which can be customized:</p> <pre><code>- the type of GroundedAtom is provided by the Atom itself;\n- the matching algorithm used by the Atom;\n- an Atom can be made executable, and used to apply sub-symbolic\n  operations to other Atoms as arguments.\n</code></pre> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n\"\"\"Initialize a GroundedAtom\"\"\"\nsuper().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees an Atom and all associated resources.\"\"\"\n#import sys; sys.stderr.write(\"Atom._del_(\" + str(self) + \")\\n\"); sys.stderr.flush()\nhp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\nreturn (isinstance(other, Atom) and\nhp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a human-readable text description of the Atom.\"\"\"\nreturn hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_grounded_type","title":"get_grounded_type","text":"<pre><code>get_grounded_type()\n</code></pre> <p>Retrieve the grounded type of the GroundedAtom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_grounded_type(self):\n\"\"\"Retrieve the grounded type of the GroundedAtom.\"\"\"\nreturn Atom._from_catom(hp.atom_get_grounded_type(self.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_object","title":"get_object","text":"<pre><code>get_object()\n</code></pre> <p>Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_object(self):\n\"\"\"Returns the GroundedAtom object, or the Space wrapped inside a GroundedAtom\"\"\"\nfrom .base import SpaceRef\nif self.get_grounded_type() == AtomType.GROUNDED_SPACE:\nreturn SpaceRef._from_cspace(hp.atom_get_space(self.catom))\nelse:\nreturn hp.atom_get_object(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n\"\"\"Gets the type of the current Atom instance\"\"\"\nreturn hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n\"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\nres = hp.atom_iterate(self.catom)\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n\"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\nreturn BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject","title":"GroundedObject","text":"<pre><code>GroundedObject(content, id = None)\n</code></pre> <p>A GroundedObject holds some content and, optionally, an identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, content, id=None):\n\"\"\"Initializes a new GroundedObject with the given content and identifier.\"\"\"\nself.content = content\nself.id = id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of  its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Returns the object's ID if present, or a string representation of \n    its content if not.\"\"\"\n# Overwrite Python default representation of a string to use\n# double quotes instead of single quotes.\nif isinstance(self.content, str):\nreturn f'\"{self.content}\"'\n# Use default representation for everything else\nreturn repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.GroundedObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a copy of this GroundedObject instance.\n    Note: Currently, this method returns the original instance.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject","title":"MatchableObject","text":"<p>             Bases: <code>ValueObject</code></p> <p>Represents an object that can be involved in a matching operation with an Atom.</p> <p>This class is meant to be subclassed by objects that define specific matching behavior with an Atom. It provides a stub method for the matching operation that raises a RuntimeError when called, which must be overridden by subclasses.</p> Inherits <p>ValueObject: The parent class that provides basic value-based equality and representation.</p> <p>Methods:</p> <ul> <li> <code>match_</code>           \u2013            <p>A stub method for matching the object with an Atom.</p> </li> </ul> Example <p>class MyMatchableObject(MatchableObject):     def match_(self, atom):         # Implement the matching logic here         pass</p> <p>my_obj = MyMatchableObject(\"some_value\") my_obj.match_(some_atom)  # Should not raise RuntimeError</p> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>Raised when the match_ method is called without being overridden by a subclass.</p> </li> </ul>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n# TODO: ?typecheck for the contents\nreturn isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of  its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Returns the object's ID if present, or a string representation of \n    its content if not.\"\"\"\n# Overwrite Python default representation of a string to use\n# double quotes instead of single quotes.\nif isinstance(self.content, str):\nreturn f'\"{self.content}\"'\n# Use default representation for everything else\nreturn repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a copy of this GroundedObject instance.\n    Note: Currently, this method returns the original instance.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableObject.match_","title":"match_","text":"<pre><code>match_(atom)\n</code></pre> <p>A stub method for matching the object with an Atom.</p> <p>This method is intended to be overridden by subclasses to provide specific matching behavior with an Atom.</p> <p>Parameters:</p> <ul> <li> <code>atom</code>             (<code>Atom</code>)         \u2013          <p>An Atom object to match against.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>           \u2013          <p>Raised when this method is called without being overridden in a subclass.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_(self, atom):\n\"\"\"\n    A stub method for matching the object with an Atom.\n    This method is intended to be overridden by subclasses to provide specific\n    matching behavior with an Atom.\n    Parameters:\n        atom (Atom): An Atom object to match against.\n    Raises:\n        RuntimeError: Raised when this method is called without being overridden in a subclass.\n    \"\"\"\nraise RuntimeError(\"MatchableObject::match_() is not implemented\")\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.NoReduceError","title":"NoReduceError","text":"<p>             Bases: <code>Exception</code></p> <p>Custom exception; raised when a reduction operation cannot be performed.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject","title":"OperationObject","text":"<pre><code>OperationObject(name, op, unwrap = True)\n</code></pre> <p>             Bases: <code>GroundedObject</code></p> <p>An OperationObject represents an operation as a grounded object, allowing for more advanced logic like lazy evaluation, type-checking, and more.</p> Inherits <p>GroundedObject: The parent class that provides the basic wrapper around content.</p> <p>Attributes:</p> <ul> <li> <code>unwrap</code>             (<code>bool</code>)         \u2013          <p>Determines whether to unwrap the content of GroundedAtoms            when passed as arguments to the operation.</p> </li> </ul> Properties <p>op: Returns the operation function. name: Returns the identifier name for this operation object.</p> <p>Methods:</p> <ul> <li> <code>execute</code>           \u2013            <p>Executes the operation with the provided arguments.</p> </li> <li> <code>__eq__</code>           \u2013            <p>Compares the equality of this OperationObject instance with another.</p> </li> </ul> Example <p>def add(a, b):     return a + b</p> <p>op_obj = OperationObject(\"addition\", add) result = op_obj.execute(3, 4)</p> <p>Parameters:     name (str): The identifier for this operation.     op (function): The function representing the operation.     unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying                              the operation. Defaults to True.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, name, op, unwrap=True):\n\"\"\"\n    Initializes a new OperationObject with a name identifier, operation function,\n    and an optional unwrap flag.\n    Parameters:\n        name (str): The identifier for this operation.\n        op (function): The function representing the operation.\n        unwrap (bool, optional): Whether to unwrap GroundedAtom content when applying\n                                 the operation. Defaults to True.\n    \"\"\"\nsuper().__init__(op, name)\nself.unwrap = unwrap\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Returns the identifier name for this operation object.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.op","title":"op  <code>property</code>","text":"<pre><code>op\n</code></pre> <p>Returns the operation function.</p>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this OperationObject with another based on their names.</p> <p>Parameters:</p> <ul> <li> <code>other</code>             (<code>OperationObject</code>)         \u2013          <p>Another OperationObject instance to compare.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>True if both OperationObjects have the same name; False otherwise.</p> </li> </ul> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"\n    Compares the equality of this OperationObject with another based on their names.\n    Parameters:\n        other (OperationObject): Another OperationObject instance to compare.\n    Returns:\n        True if both OperationObjects have the same name; False otherwise.\n    \"\"\"\nreturn isinstance(other, OperationObject) and self.name == other.name\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of  its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Returns the object's ID if present, or a string representation of \n    its content if not.\"\"\"\n# Overwrite Python default representation of a string to use\n# double quotes instead of single quotes.\nif isinstance(self.content, str):\nreturn f'\"{self.content}\"'\n# Use default representation for everything else\nreturn repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a copy of this GroundedObject instance.\n    Note: Currently, this method returns the original instance.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationObject.execute","title":"execute","text":"<pre><code>execute(*args, res_typ = AtomType.UNDEFINED)\n</code></pre> <p>Executes the operation with the provided arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>         \u2013          <p>Arguments to pass to the operation function.</p> </li> <li> <code>res_typ</code>             (<code>AtomType</code>, default:                 <code>UNDEFINED</code> )         \u2013          <p>The expected result type. Defaults to AtomType.UNDEFINED.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>The result of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoReduceError</code>           \u2013          <p>Raised when <code>unwrap=True</code> and a non-GroundedAtom argument is provided.</p> </li> <li> <code>RuntimeError</code>           \u2013          <p>Raised when the result of the operation is not a list.</p> </li> </ul> Note <p>Depending on the <code>unwrap</code> attribute, this method will either unwrap GroundedAtoms before passing them to the operation or pass them as is.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def execute(self, *args, res_typ=AtomType.UNDEFINED):\n\"\"\"\n    Executes the operation with the provided arguments.\n    Parameters:\n        *args: Arguments to pass to the operation function.\n        res_typ (AtomType, optional): The expected result type. Defaults to AtomType.UNDEFINED.\n    Returns:\n        The result of the operation.\n    Raises:\n        NoReduceError: Raised when `unwrap=True` and a non-GroundedAtom argument is provided.\n        RuntimeError: Raised when the result of the operation is not a list.\n    Note:\n        Depending on the `unwrap` attribute, this method will either unwrap GroundedAtoms\n        before passing them to the operation or pass them as is.\n    \"\"\"\n# type-check?\nif self.unwrap:\nfor arg in args:\nif not isinstance(arg, GroundedAtom):\n# REM:\n# Currently, applying grounded operations to pure atoms is not reduced.\n# If we want, we can raise an exception, or form an error expression instead,\n# so a MeTTa program can catch and analyze it.\n# raise RuntimeError(\"Grounded operation \" + self.name + \" with unwrap=True expects only grounded arguments\")\nraise NoReduceError()\nargs = [arg.get_object().content for arg in args]\nreturn [G(ValueObject(self.op(*args)), res_typ)]\nelse:\nresult = self.op(*args)\nif not isinstance(result, list):\nraise RuntimeError(\"Grounded operation `\" + self.name + \"` should return list\")\nreturn result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom","title":"SymbolAtom","text":"<pre><code>SymbolAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>A SymbolAtom represents a single concept, identified by name. If two symbols have the same name, they reference the same concept.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n\"\"\"Initialize a SymbolAtom\"\"\"\nsuper().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees an Atom and all associated resources.\"\"\"\n#import sys; sys.stderr.write(\"Atom._del_(\" + str(self) + \")\\n\"); sys.stderr.flush()\nhp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\nreturn (isinstance(other, Atom) and\nhp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a human-readable text description of the Atom.\"\"\"\nreturn hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n\"\"\"Returns the name of the Atom.\"\"\"\nreturn hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n\"\"\"Gets the type of the current Atom instance\"\"\"\nreturn hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n\"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\nres = hp.atom_iterate(self.catom)\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.SymbolAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n\"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\nreturn BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject","title":"ValueObject","text":"<p>             Bases: <code>GroundedObject</code></p> <p>A ValueObject is a specialized form of GroundedObject, which treats its content as a value. It allows for equality comparison between the content of two ValueObjects.</p> Example <p>obj1 = ValueObject(5) obj2 = ValueObject(5) obj3 = ValueObject(6)</p> <p>print(obj1 == obj2)  # True print(obj1 == obj3)  # False</p>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Gets the value of the object, which is its content.</p>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compares the equality of this ValueObject with another based on their content.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Compares the equality of this ValueObject with another based on their content.\"\"\"\n# TODO: ?typecheck for the contents\nreturn isinstance(other, ValueObject) and self.content == other.content\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Returns the object's ID if present, or a string representation of  its content if not.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Returns the object's ID if present, or a string representation of \n    its content if not.\"\"\"\n# Overwrite Python default representation of a string to use\n# double quotes instead of single quotes.\nif isinstance(self.content, str):\nreturn f'\"{self.content}\"'\n# Use default representation for everything else\nreturn repr(self.content) if self.id is None else self.id\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueObject.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a copy of this GroundedObject instance.</p> <p>Note: Currently, this method returns the original instance.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a copy of this GroundedObject instance.\n    Note: Currently, this method returns the original instance.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom","title":"VariableAtom","text":"<pre><code>VariableAtom(catom)\n</code></pre> <p>             Bases: <code>Atom</code></p> <p>A VariableAtom represents a variable in an expression. It serves as a placeholder that can be matched with, or bound to other Atoms.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __init__(self, catom):\n\"\"\"Initialize a VariableAtom\"\"\"\nsuper().__init__(catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Frees an Atom and all associated resources.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __del__(self):\n\"\"\"Frees an Atom and all associated resources.\"\"\"\n#import sys; sys.stderr.write(\"Atom._del_(\" + str(self) + \")\\n\"); sys.stderr.flush()\nhp.atom_free(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if two atom objects represent the same conceptual Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Checks if two atom objects represent the same conceptual Atom.\"\"\"\nreturn (isinstance(other, Atom) and\nhp.atom_eq(self.catom, other.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Renders a human-readable text description of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def __repr__(self):\n\"\"\"Renders a human-readable text description of the Atom.\"\"\"\nreturn hp.atom_to_str(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_name","title":"get_name","text":"<pre><code>get_name()\n</code></pre> <p>Returns the name of the Atom.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_name(self):\n\"\"\"Returns the name of the Atom.\"\"\"\nreturn hp.atom_get_name(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.get_type","title":"get_type","text":"<pre><code>get_type()\n</code></pre> <p>Gets the type of the current Atom instance</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def get_type(self):\n\"\"\"Gets the type of the current Atom instance\"\"\"\nreturn hp.atom_get_type(self.catom)\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.iterate","title":"iterate","text":"<pre><code>iterate()\n</code></pre> <p>Performs a depth-first exhaustive iteration of an Atom and all its children recursively.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def iterate(self):\n\"\"\"Performs a depth-first exhaustive iteration of an Atom and all its children recursively.\"\"\"\nres = hp.atom_iterate(self.catom)\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.VariableAtom.match_atom","title":"match_atom","text":"<pre><code>match_atom(b)\n</code></pre> <p>Matches one Atom with another, establishing bindings between them.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def match_atom(self, b):\n\"\"\"Matches one Atom with another, establishing bindings between them.\"\"\"\nreturn BindingsSet(hp.atom_match_atom(self.catom, b.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.E","title":"E","text":"<pre><code>E(*args)\n</code></pre> <p>A convenient method to construct an ExpressionAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def E(*args):\n\"\"\"A convenient method to construct an ExpressionAtom\"\"\"\nreturn ExpressionAtom(hp.atom_expr([atom.catom for atom in args]))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.G","title":"G","text":"<pre><code>G(object, type = AtomType.UNDEFINED)\n</code></pre> <p>A convenient method to construct a GroundedAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def G(object, type=AtomType.UNDEFINED):\n\"\"\"A convenient method to construct a GroundedAtom\"\"\"\nassert hasattr(object, \"copy\"), \"Method copy should be implemented by grounded object\"\nreturn GroundedAtom(hp.atom_gnd(object, type.catom))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.MatchableAtom","title":"MatchableAtom","text":"<pre><code>MatchableAtom(value, type_name = None, atom_id = None)\n</code></pre> <p>Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def MatchableAtom(value, type_name=None, atom_id=None):\n\"\"\"\n    Creates a Grounded Atom that wraps a matchable value, optionally specifying its type and identifier.\n    \"\"\"\nreturn G(MatchableObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.OperationAtom","title":"OperationAtom","text":"<pre><code>OperationAtom(name, op, type_names = None, unwrap = True)\n</code></pre> <p>An OperationAtom wraps an operation with optional type information into a GroundedAtom and associates a name with it. Useful for registering custom operations that can be executed in an Atom-based computational environment.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def OperationAtom(name, op, type_names=None, unwrap=True):\n\"\"\"\n    An OperationAtom wraps an operation with optional type information into a GroundedAtom\n    and associates a name with it. Useful for registering custom operations\n    that can be executed in an Atom-based computational environment.\n    \"\"\"\nreturn G(OperationObject(name, op, unwrap), _type_sugar(type_names))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.S","title":"S","text":"<pre><code>S(name)\n</code></pre> <p>A convenient method to construct a SymbolAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def S(name):\n\"\"\"A convenient method to construct a SymbolAtom\"\"\"\nreturn SymbolAtom(hp.atom_sym(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.V","title":"V","text":"<pre><code>V(name)\n</code></pre> <p>A convenient method to construct a VariableAtom</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def V(name):\n\"\"\"A convenient method to construct a VariableAtom\"\"\"\nreturn VariableAtom(hp.atom_var(name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.ValueAtom","title":"ValueAtom","text":"<pre><code>ValueAtom(value, type_name = None, atom_id = None)\n</code></pre> <p>Creates a GroundedAtom that wraps a given value, optionally specifying its type and identifier.</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def ValueAtom(value, type_name=None, atom_id=None):\n\"\"\"Creates a GroundedAtom that wraps a given value, optionally specifying its type and identifier.\"\"\"\nreturn G(ValueObject(value, atom_id), _type_sugar(type_name))\n</code></pre>"},{"location":"reference/atoms/#hyperon.atoms.atoms_are_equivalent","title":"atoms_are_equivalent","text":"<pre><code>atoms_are_equivalent(first, second)\n</code></pre> <p>Check if two atoms are equivalent</p> Source code in <code>python/hyperon/atoms.py</code> <pre><code>def atoms_are_equivalent(first, second):\n\"\"\"Check if two atoms are equivalent\"\"\"\nreturn hp.atoms_are_equivalent(first.catom, second.catom)\n</code></pre>"},{"location":"reference/base/","title":"Base","text":""},{"location":"reference/base/#hyperon.base","title":"base","text":""},{"location":"reference/base/#hyperon.base.AbstractSpace","title":"AbstractSpace","text":"<pre><code>AbstractSpace()\n</code></pre> <p>A virtual base class upon which Spaces can be implemented in Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self):\n\"\"\"Initialiize the AbstractSpace. Does nothing in the base class\"\"\"\nreturn\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n\"\"\"\n    Adds an Atom to the atom space. Must be implemented in derived classes.\n    \"\"\"\nraise RuntimeError(\"Space::add() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of atoms in the atom space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n\"\"\"\n    Counts the number of atoms in the atom space. Optional for derived classes.\n    \"\"\"\nNone\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the Space. Optional for derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n\"\"\"\n    Returns an iterator over atoms in the Space. Optional for derived classes.\n    \"\"\"\nNone\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Performs the specified query on the Space. Should be overridden to return a BindingsSet as the result of the query.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n\"\"\"\n    Performs the specified query on the Space.\n    Should be overridden to return a BindingsSet as the result of the query.\n    \"\"\"\nraise RuntimeError(\"Space::query() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n\"\"\"\n    Removes an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\nraise RuntimeError(\"Space::remove() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.AbstractSpace.replace","title":"replace","text":"<pre><code>replace(atom, replacement)\n</code></pre> <p>Replaces an Atom from the atom space. Must be implemented in derived classes.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, atom, replacement):\n\"\"\"\n    Replaces an Atom from the atom space. Must be implemented in derived classes.\n    \"\"\"\nraise RuntimeError(\"Space::replace() is not implemented\")\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace","title":"GroundingSpace","text":"<pre><code>GroundingSpace(unwrap = True)\n</code></pre> <p>             Bases: <code>AbstractSpace</code></p> <p>A wrapper over the native GroundingSpace implementation, which can be subclassed and extended within Python</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, unwrap=True):\n\"\"\"Initialize GroundingSpace and its underlying native implementation.\"\"\"\nsuper().__init__()\n# self.cspace = hp.space_new_grounding()\nself.gspace = GroundingSpaceRef()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.add","title":"add","text":"<pre><code>add(atom)\n</code></pre> <p>Adds an Atom to the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add(self, atom):\n\"\"\"\n    Adds an Atom to the atom space.\n    \"\"\"\nself.gspace.add_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Counts the number of Atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n\"\"\"\n    Counts the number of Atoms in the atom space.\n    \"\"\"\nreturn self.gspace.atom_count()\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.atoms_iter","title":"atoms_iter","text":"<pre><code>atoms_iter()\n</code></pre> <p>Returns an iterator over atoms in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atoms_iter(self):\n\"\"\"\n    Returns an iterator over atoms in the atom space.\n    \"\"\"\nreturn iter(self.gspace.get_atoms())\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.query","title":"query","text":"<pre><code>query(query_atom)\n</code></pre> <p>Delegates the query to the underlying native GroundingSpace and returns the result BindingsSet</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, query_atom):\n\"\"\"\n    Delegates the query to the underlying native GroundingSpace\n    and returns the result BindingsSet\n    \"\"\"\nreturn self.gspace.query(query_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.remove","title":"remove","text":"<pre><code>remove(atom)\n</code></pre> <p>Removes an Atom from the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove(self, atom):\n\"\"\"\n    Removes an Atom from the atom space.\n    \"\"\"\nreturn self.gspace.remove_atom(atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpace.replace","title":"replace","text":"<pre><code>replace(from_atom, to_atom)\n</code></pre> <p>Replaces an Atom in the atom space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace(self, from_atom, to_atom):\n\"\"\"\n    Replaces an Atom in the atom space.\n    \"\"\"\nreturn self.gspace.replace_atom(from_atom, to_atom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef","title":"GroundingSpaceRef","text":"<pre><code>GroundingSpaceRef(cspace = None)\n</code></pre> <p>             Bases: <code>SpaceRef</code></p> <p>A reference to a native GroundingSpace, implemented by the MeTTa core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, cspace = None):\n\"\"\"\n    Initialize a new GroundingSpaceRef.\n    If a CSpace object is provided, use it; otherwise create a new GroundingSpace.\n    \"\"\"\nif cspace is None:\nself.cspace = hp.space_new_grounding()\nelse:\nself.cspace = cspace\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n\"\"\"Free the underlying CSpace object \"\"\"\nhp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\nreturn hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n\"\"\"\n    Add an Atom to the Space.\n    \"\"\"\nhp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n\"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\nreturn hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n\"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\nres = hp.space_list(self.cspace)\nif res == None:\nreturn None\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n\"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\nreturn hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n\"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\nresult = hp.space_query(self.cspace, pattern.catom)\nreturn BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n\"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\nreturn hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n\"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\nreturn hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.GroundingSpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n\"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\nreturn [Atom._from_catom(catom) for catom in\nhp.space_subst(self.cspace, pattern.catom,\ntempl.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter","title":"Interpreter","text":"<pre><code>Interpreter(gnd_space, expr)\n</code></pre> <p>A wrapper class for the MeTTa interpreter that handles the interpretation of expressions in a given grounding space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, gnd_space, expr):\n\"\"\"\n    Initializes the interpreter with the given grounding space and expression.\n    \"\"\"\nself.step_result = hp.interpret_init(gnd_space.cspace, expr.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_result","title":"get_result","text":"<pre><code>get_result()\n</code></pre> <p>Retrieves the final outcome of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_result(self):\n\"\"\"\n    Retrieves the final outcome of the interpretation plan.\n    \"\"\"\nif self.has_next():\nraise RuntimeError(\"Plan execution is not finished\")\nreturn hp.step_get_result(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.get_step_result","title":"get_step_result","text":"<pre><code>get_step_result()\n</code></pre> <p>Gets the current result of the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_step_result(self):\n\"\"\"\n    Gets the current result of the interpretation plan.\n    \"\"\"\nreturn self.step_result\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.has_next","title":"has_next","text":"<pre><code>has_next()\n</code></pre> <p>Checks if there are more steps to execute in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def has_next(self):\n\"\"\"\n    Checks if there are more steps to execute in the interpretation plan.\n    \"\"\"\nreturn hp.step_has_next(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Interpreter.next","title":"next","text":"<pre><code>next()\n</code></pre> <p>Executes the next step in the interpretation plan.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def next(self):\n\"\"\"\n    Executes the next step in the interpretation plan.\n    \"\"\"\nif not self.has_next():\nraise StopIteration()\nself.step_result = hp.interpret_step(self.step_result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser","title":"SExprParser","text":"<pre><code>SExprParser(text)\n</code></pre> <p>A class responsible for parsing S-expressions (Symbolic Expressions). This class wraps around a SExprParser object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, text):\n\"\"\"Initialize a new SExprParser object.\"\"\"\nself.cparser = hp.CSExprParser(text)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SExprParser.parse","title":"parse","text":"<pre><code>parse(tokenizer)\n</code></pre> <p>Parses the S-expression using the provided Tokenizer.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def parse(self, tokenizer):\n\"\"\"\n    Parses the S-expression using the provided Tokenizer.\n    \"\"\"\ncatom = self.cparser.parse(tokenizer.ctokenizer)\nreturn Atom._from_catom(catom) if catom is not None else None\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef","title":"SpaceRef","text":"<pre><code>SpaceRef(space_obj)\n</code></pre> <p>A reference to a Space, which may be accessed directly, wrapped in a grounded atom, or passed to a MeTTa interpreter.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, space_obj):\n\"\"\"\n    Initialize a new SpaceRef based on the given space object, either a CSpace \n    or a custom Python object.\n    \"\"\"\nif type(space_obj) is hp.CSpace:\nself.cspace = space_obj\nelse:\nself.cspace = hp.space_new_custom(space_obj)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Free the underlying CSpace object</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n\"\"\"Free the underlying CSpace object \"\"\"\nhp.space_free(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Compare two SpaceRef objects for equality, based on their underlying spaces.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __eq__(self, other):\n\"\"\"Compare two SpaceRef objects for equality, based on their underlying spaces.\"\"\"\nreturn hp.space_eq(self.cspace, other.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.add_atom","title":"add_atom","text":"<pre><code>add_atom(atom)\n</code></pre> <p>Add an Atom to the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def add_atom(self, atom):\n\"\"\"\n    Add an Atom to the Space.\n    \"\"\"\nhp.space_add(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.atom_count","title":"atom_count","text":"<pre><code>atom_count()\n</code></pre> <p>Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def atom_count(self):\n\"\"\"\n    Returns the number of Atoms in the Space, or -1 if it cannot be readily computed.\n    \"\"\"\nreturn hp.space_atom_count(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Returns a new copy of the SpaceRef, referencing the same underlying Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a new copy of the SpaceRef, referencing the same underlying Space.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_atoms","title":"get_atoms","text":"<pre><code>get_atoms()\n</code></pre> <p>Returns a list of all Atoms in the Space, or None if that is impossible.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atoms(self):\n\"\"\"\n    Returns a list of all Atoms in the Space, or None if that is impossible.\n    \"\"\"\nres = hp.space_list(self.cspace)\nif res == None:\nreturn None\nresult = []\nfor r in res:\nresult.append(Atom._from_catom(r))\nreturn result\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.get_payload","title":"get_payload","text":"<pre><code>get_payload()\n</code></pre> <p>Returns the Space object referenced by the SpaceRef, or None if the object does not have a direct Python interface.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_payload(self):\n\"\"\"\n    Returns the Space object referenced by the SpaceRef, or None if the object does not have a\n    direct Python interface.\n    \"\"\"\nreturn hp.space_get_payload(self.cspace)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.query","title":"query","text":"<pre><code>query(pattern)\n</code></pre> <p>Performs the specified query on the Space, and returns the result as a BindingsSet.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def query(self, pattern):\n\"\"\"\n    Performs the specified query on the Space, and returns the result as a BindingsSet.\n    \"\"\"\nresult = hp.space_query(self.cspace, pattern.catom)\nreturn BindingsSet(result)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.remove_atom","title":"remove_atom","text":"<pre><code>remove_atom(atom)\n</code></pre> <p>Delete the specified Atom from the Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def remove_atom(self, atom):\n\"\"\"\n    Delete the specified Atom from the Space.\n    \"\"\"\nreturn hp.space_remove(self.cspace, atom.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.replace_atom","title":"replace_atom","text":"<pre><code>replace_atom(atom, replacement)\n</code></pre> <p>Replaces the specified Atom, if it exists in the Space, with the supplied replacement.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def replace_atom(self, atom, replacement):\n\"\"\"\n    Replaces the specified Atom, if it exists in the Space, with the supplied replacement.\n    \"\"\"\nreturn hp.space_replace(self.cspace, atom.catom, replacement.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.SpaceRef.subst","title":"subst","text":"<pre><code>subst(pattern, templ)\n</code></pre> <p>Performs a substitution within the Space, based on a pattern and a template.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def subst(self, pattern, templ):\n\"\"\"\n    Performs a substitution within the Space, based on a pattern and a template.\n    \"\"\"\nreturn [Atom._from_catom(catom) for catom in\nhp.space_subst(self.cspace, pattern.catom,\ntempl.catom)]\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer","title":"Tokenizer","text":"<pre><code>Tokenizer(ctokenizer = None)\n</code></pre> <p>A class responsible for text tokenization in the context of Hyperon. This class wraps around a Tokenizer object from the core library.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __init__(self, ctokenizer = None):\n\"\"\"\n    Initialize a new Tokenizer.\n    \"\"\"\nif ctokenizer is None:\nself.ctokenizer = hp.tokenizer_new()\nelse:\nself.ctokenizer = ctokenizer\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.__del__","title":"__del__","text":"<pre><code>__del__()\n</code></pre> <p>Destructor that frees the underlying resources when the Tokenizer instance is destroyed.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def __del__(self):\n\"\"\"\n    Destructor that frees the underlying resources when the Tokenizer instance is destroyed.\n    \"\"\"\nhp.tokenizer_free(self.ctokenizer)\n</code></pre>"},{"location":"reference/base/#hyperon.base.Tokenizer.register_token","title":"register_token","text":"<pre><code>register_token(regex, constr)\n</code></pre> <p>Registers a new custom Token in the Tokenizer based on a regular expression.</p> <p>Parameters:</p> <p>regex:     A string representing the regular expression to match incoming text.     Hyperon uses the Rust RegEx engine and syntax. constr:     A constructor function for generating a new atom when the regex is triggered.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def register_token(self, regex, constr):\n\"\"\"\n    Registers a new custom Token in the Tokenizer based on a regular expression.\n    Parameters:\n    ----------\n    regex:\n       A string representing the regular expression to match incoming text.\n       Hyperon uses the Rust RegEx engine and syntax.\n   constr:\n       A constructor function for generating a new atom when the regex is triggered.\n   \"\"\"\nhp.tokenizer_register_token(self.ctokenizer, regex, constr)\n</code></pre>"},{"location":"reference/base/#hyperon.base.check_type","title":"check_type","text":"<pre><code>check_type(gnd_space, atom, type)\n</code></pre> <p>Checks whether the given Atom has the specified type in the given space context.</p>"},{"location":"reference/base/#hyperon.base.check_type--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check type:     A pointer to the atom_t or atom_ref_t representing the type to check against</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def check_type(gnd_space, atom, type):\n\"\"\"\n    Checks whether the given Atom has the specified type in the given space context.\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n    type:\n        A pointer to the atom_t or atom_ref_t representing the type to check against\n    \"\"\"\nreturn hp.check_type(gnd_space.cspace, atom.catom, type.catom)\n</code></pre>"},{"location":"reference/base/#hyperon.base.get_atom_types","title":"get_atom_types","text":"<pre><code>get_atom_types(gnd_space, atom)\n</code></pre> <p>Provides all types for the given Atom in the context of the given Space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def get_atom_types(gnd_space, atom):\n\"\"\"Provides all types for the given Atom in the context of the given Space.\"\"\"\nresult = hp.get_atom_types(gnd_space.cspace, atom.catom)\nreturn [Atom._from_catom(catom) for catom in result]\n</code></pre>"},{"location":"reference/base/#hyperon.base.interpret","title":"interpret","text":"<pre><code>interpret(gnd_space, expr)\n</code></pre> <p>Parses the given expression in the specified grounding space.</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def interpret(gnd_space, expr):\n\"\"\"\n    Parses the given expression in the specified grounding space.\n    \"\"\"\ninterpreter = Interpreter(gnd_space, expr)\nwhile interpreter.has_next():\ninterpreter.next()\nreturn [Atom._from_catom(catom) for catom in interpreter.get_result()]\n</code></pre>"},{"location":"reference/base/#hyperon.base.validate_atom","title":"validate_atom","text":"<pre><code>validate_atom(gnd_space, atom)\n</code></pre> <p>Checks whether the given Atom is correctly typed.</p>"},{"location":"reference/base/#hyperon.base.validate_atom--parameters","title":"Parameters","text":"<p>gnd_space:     A pointer to the space_t representing the space context in which to perform     the check atom:     A pointer to the atom_t or atom_ref_t representing the atom whose Type the     function will check</p>"},{"location":"reference/base/#hyperon.base.validate_atom--returns","title":"Returns","text":"<p>True if the Atom is correctly typed, otherwise false</p> Source code in <code>python/hyperon/base.py</code> <pre><code>def validate_atom(gnd_space, atom):\n\"\"\"\n    Checks whether the given Atom is correctly typed.\n    Parameters\n    ----------\n    gnd_space:\n        A pointer to the space_t representing the space context in which to perform\n        the check\n    atom:\n        A pointer to the atom_t or atom_ref_t representing the atom whose Type the\n        function will check\n    Returns\n    -------\n    True if the Atom is correctly typed, otherwise false\n    \"\"\"\nreturn hp.validate_atom(gnd_space.cspace, atom.catom)\n</code></pre>"},{"location":"reference/ext/","title":"Ext","text":""},{"location":"reference/ext/#hyperon.ext","title":"ext","text":""},{"location":"reference/ext/#hyperon.ext.register_atoms","title":"register_atoms","text":"<pre><code>register_atoms(*args, pass_metta = False, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and atoms in MeTTa tokenizer using MeTTa.register_atom() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_atoms--parameters","title":"Parameters","text":"<p>pass_metta:     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_atoms(*args, pass_metta=False, **kwargs):\n\"\"\"Function decorator which registers returned pairs of regular expressions\n    and atoms in MeTTa tokenizer using MeTTa.register_atom() method.\n    Parameters\n    ----------\n    pass_metta:\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\ndef register_atoms_internal(metta, regs):\nfor rex, atom in regs.items():\nmetta.register_atom(rex, atom)\nreturn register_results(register_atoms_internal, args, kwargs)\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_results","title":"register_results","text":"<pre><code>register_results(method, args, kwargs)\n</code></pre> <p>Returns a decorator for registering the results of a method. The behavior of the decorator depends on whether it is used with or without arguments.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_results(method, args, kwargs):\n\"\"\"Returns a decorator for registering the results of a method.\n    The behavior of the decorator depends on whether it is used with or without arguments.\"\"\"\n# Case 1: Decorator used without arguments (i.e., @decorator instead of @decorator(args))\nif len(args) == 1 and len(kwargs) == 0 and callable(args[0]):\nfunc = args[0]  # func is the decorated function\n# Define the decorator\ndef metta_register(metta):\n# Register the results of calling the decorated function using the provided method\nmethod(metta, func())\nreturn metta_register\n# Case 2: Decorator used with arguments (i.e., @decorator(args))\nelse:\n# Check if the decorator is used with arguments\npass_metta = kwargs.get('pass_metta', False)\n# Define the decorator\ndef inner(func):\ndef metta_register(metta):\n# Get the results of calling the decorated function\nregs = func(metta) if pass_metta else func()\n# Register the results using the provided method\nmethod(metta, regs)\nreturn metta_register\nreturn inner\n</code></pre>"},{"location":"reference/ext/#hyperon.ext.register_tokens","title":"register_tokens","text":"<pre><code>register_tokens(*args, **kwargs)\n</code></pre> <p>Function decorator which registers returned pairs of regular expressions and lambdas in MeTTa tokenizer using MeTTa.register_token() method.</p>"},{"location":"reference/ext/#hyperon.ext.register_tokens--parameters","title":"Parameters","text":"<p>pass_metta : bool, optional     Pass instance of MeTTa class to the decorated function as an argument.     Default is False.</p> Source code in <code>python/hyperon/ext.py</code> <pre><code>def register_tokens(*args, **kwargs):\n\"\"\"Function decorator which registers returned pairs of regular expressions\n    and lambdas in MeTTa tokenizer using MeTTa.register_token() method.\n    Parameters\n    ----------\n    pass_metta : bool, optional\n        Pass instance of MeTTa class to the decorated function as an argument.\n        Default is False.\n    \"\"\"\ndef register_tokens_internal(metta, regs):\nfor rex, lam in regs.items():\nmetta.register_token(rex, lam)\nreturn register_results(register_tokens_internal, args, kwargs)\n</code></pre>"},{"location":"reference/runner/","title":"Runner","text":""},{"location":"reference/runner/#hyperon.runner","title":"runner","text":""},{"location":"reference/runner/#hyperon.runner.MeTTa","title":"MeTTa","text":"<pre><code>MeTTa(space = None, cwd = '.', cmetta = None)\n</code></pre> <p>This class contains the MeTTa program execution utilities</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def __init__(self, space = None, cwd = \".\", cmetta = None):\nif cmetta is not None:\nself.cmetta = cmetta\nelse:\nif space is None:\nspace = GroundingSpaceRef()\ntokenizer = Tokenizer()\nself.cmetta = hp.metta_new(space.cspace, tokenizer.ctokenizer, cwd)\nself.load_py_module(\"hyperon.stdlib\")\nhp.metta_load_module(self.cmetta, \"stdlib\")\nself.register_atom('extend-py!',\nOperationAtom('extend-py!',\nlambda name: self.load_py_module(name) or [],\n[AtomType.UNDEFINED, AtomType.ATOM], unwrap=False))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.import_file","title":"import_file","text":"<pre><code>import_file(fname)\n</code></pre> <p>Loads the program file and runs it</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def import_file(self, fname):\n\"\"\"Loads the program file and runs it\"\"\"\npath = fname.split(os.sep)\nif len(path) == 1:\npath = ['.'] + path\nf = open(os.sep.join(path), \"r\")\nprogram = f.read()\nf.close()\n# changing cwd\nprev_cwd = os.getcwd()\nos.chdir(os.sep.join(path[:-1]))\nresult = self.run(program)\n# restoring cwd\nos.chdir(prev_cwd)\nreturn result\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.load_py_module","title":"load_py_module","text":"<pre><code>load_py_module(name)\n</code></pre> <p>Loads the given python module</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def load_py_module(self, name):\n\"\"\"Loads the given python module\"\"\"\nif not isinstance(name, str):\nname = repr(name)\nmod = import_module(name)\nfor n in dir(mod):\nobj = getattr(mod, n)\nif '__name__' in dir(obj) and obj.__name__ == 'metta_register':\nobj(self)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_all","title":"parse_all","text":"<pre><code>parse_all(program)\n</code></pre> <p>Parse the entire program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_all(self, program):\n\"\"\"Parse the entire program\"\"\"\nreturn list(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.parse_single","title":"parse_single","text":"<pre><code>parse_single(program)\n</code></pre> <p>Parse the next single line in the program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def parse_single(self, program):\n\"\"\"Parse the next single line in the program\"\"\"\nreturn next(self._parse_all(program))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_atom","title":"register_atom","text":"<pre><code>register_atom(name, symbol)\n</code></pre> <p>Registers an Atom</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_atom(self, name, symbol):\n\"\"\"Registers an Atom\"\"\"\nself.register_token(name, lambda _: symbol)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.register_token","title":"register_token","text":"<pre><code>register_token(regexp, constr)\n</code></pre> <p>Registers a token</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def register_token(self, regexp, constr):\n\"\"\"Registers a token\"\"\"\nself.tokenizer().register_token(regexp, constr)\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.run","title":"run","text":"<pre><code>run(program, flat = False)\n</code></pre> <p>Runs the program</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def run(self, program, flat=False):\n\"\"\"Runs the program\"\"\"\nparser = SExprParser(program)\nresults = hp.metta_run(self.cmetta, parser.cparser)\nif flat:\nreturn [Atom._from_catom(catom) for result in results for catom in result]\nelse:\nreturn [[Atom._from_catom(catom) for catom in result] for result in results]\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.space","title":"space","text":"<pre><code>space()\n</code></pre> <p>Gets the metta space</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def space(self):\n\"\"\"Gets the metta space\"\"\"\nreturn GroundingSpaceRef._from_cspace(hp.metta_space(self.cmetta))\n</code></pre>"},{"location":"reference/runner/#hyperon.runner.MeTTa.tokenizer","title":"tokenizer","text":"<pre><code>tokenizer()\n</code></pre> <p>Gets the tokenizer</p> Source code in <code>python/hyperon/runner.py</code> <pre><code>def tokenizer(self):\n\"\"\"Gets the tokenizer\"\"\"\nreturn Tokenizer._from_ctokenizer(hp.metta_tokenizer(self.cmetta))\n</code></pre>"},{"location":"reference/stdlib/","title":"Stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib","title":"stdlib","text":""},{"location":"reference/stdlib/#hyperon.stdlib.Char","title":"Char","text":"<pre><code>Char(char)\n</code></pre> <p>Emulate Char type as in a traditional FPL</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>def __init__(self, char):\nif len(char) != 1:\nraise ValueError(\"A Char object must be initialized with a single character.\")\nself.char = char\n</code></pre>"},{"location":"reference/stdlib/#hyperon.stdlib.text_ops","title":"text_ops","text":"<pre><code>text_ops()\n</code></pre> <p>Add text operators</p> <p>repr: convert Atom to string. parse: convert String to Atom. stringToChars: convert String to tuple of Char. charsToString: convert tuple of Char to String.</p> <p>see test_stdlib.py for examples.</p> Source code in <code>python/hyperon/stdlib.py</code> <pre><code>@register_atoms\ndef text_ops():\n\"\"\"Add text operators\n    repr: convert Atom to string.\n    parse: convert String to Atom.\n    stringToChars: convert String to tuple of Char.\n    charsToString: convert tuple of Char to String.\n    see test_stdlib.py for examples.\n    \"\"\"\nreprAtom = OperationAtom('repr', lambda a: [ValueAtom(repr(a))],\n['Atom', 'String'], unwrap=False)\nparseAtom = OperationAtom('parse', lambda s: [ValueAtom(SExprParser(str(s)[1:-1]).parse(Tokenizer()))],\n['String', 'Atom'], unwrap=False)\nstringToCharsAtom = OperationAtom('stringToChars', lambda s: [ValueAtom(E(*[ValueAtom(Char(c)) for c in str(s)[1:-1]]))],\n['String', 'Atom'], unwrap=False)\ncharsToStringAtom = OperationAtom('charsToString', lambda a: [ValueAtom(\"\".join([str(c)[1:-1] for c in a.get_children()]))],\n['Atom', 'String'], unwrap=False)\nreturn {\nr\"repr\": reprAtom,\nr\"parse\": parseAtom,\nr\"stringToChars\": stringToCharsAtom,\nr\"charsToString\": charsToStringAtom\n}\n</code></pre>"}]}